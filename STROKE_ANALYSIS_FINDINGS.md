# ストロークとシャドウパラメータの解析結果

**解析日**: 2025-12-12
**解析対象**: 184バイト差分（Fontstyle_01 vs Fontstyle_11）および複雑なスタイル（Fontstyle_90）

---

## 🎯 主要な発見

### 1. ストロークデータの存在確認

| スタイル | サイズ | ストローク | 追加バイト数 |
|----------|--------|-----------|-------------|
| Fontstyle_01-10 | 732 bytes | なし | - |
| Fontstyle_11-20 | 916 bytes | あり | +184 bytes |
| Fontstyle_82-90 | 1756 bytes | 複数あり | +1024 bytes |

**結論**: ストローク1つあたり約184バイトのデータが追加される

### 2. ストロークパラメータの位置（Fontstyle_11, 916バイト）

#### ストローク幅
- **位置**: 0x0184
- **形式**: float32 (little-endian)
- **値**: 16.0 pt

```python
stroke_width = struct.unpack("<f", binary[0x184:0x188])[0]
# 結果: 16.0
```

#### ストローク不透明度
- **位置**: 0x0180
- **形式**: float32
- **値**: 100.0 (= 100%)

#### ストローク色（RGBA float形式）

**色1**: 位置 0x01bc
```
Hex: 04 00 08 00 0a 00 00 00 00 00 80 3f 00 00 00 3f
     [   メタデータ?   ] [   B=1.0  ] [   A=0.5  ]
RGBA float: (0.0, 0.0, 1.0, 0.5) → RGB(0, 0, 255, 127)
```

**色2**: 位置 0x01ec
```
同様のパターン: RGB(0, 0, 255, 127)
```

**解釈**: 2箇所に同じ青色 = グラデーションストロークのstart/endカラー

### 3. 複雑なスタイルの解析（Fontstyle_90, 1756バイト）

#### 検出されたRGBA色

| 位置 | RGBA float | RGB (0-255) | 用途推定 |
|------|-----------|-------------|----------|
| 0x051c | (0.0, 0.0, 0.0, 1.0) | RGB(0, 0, 0, 255) | ストローク/シャドウ（黒・不透明） |
| 0x0520 | (0.0, 0.0, 1.0, 0.5) | RGB(0, 0, 255, 127) | ストローク（青・半透明） |
| 0x0644 | (0.0, 0.0, 0.0, 1.0) | RGB(0, 0, 0, 255) | ストローク/シャドウ（黒・不透明） |
| 0x0648 | (0.0, 0.0, 1.0, 0.5) | RGB(0, 0, 255, 127) | ストローク（青・半透明） |

**パターン**: 黒色2箇所 + 青色2箇所 = 複数のストロークレイヤーまたはグラデーション

#### サイズ差から推測されるストローク数

```
サイズ差: 1756 - 732 = 1024 bytes
1024 / 184 ≈ 5.6

推測: 約5-6個のストロークレイヤー
```

---

## 📊 色データ形式の2種類

### 形式1: RGB Bytes（テキストの塗り色）

- **サイズ**: 3-4バイト
- **範囲**: 0-255
- **位置**: 可変（例: 0x0214, 0x02aa）
- **例**:
  ```
  Fontstyle_01 (0x0214): 00 fd 71 71
  → R=0, G=253, B=113, A=113
  ```

### 形式2: RGBA Float（ストローク/グラデーション）

- **サイズ**: 16バイトブロック
- **範囲**: 0.0-1.0
- **構造**:
  ```
  [8バイト: メタデータ/VTable参照?] [4バイト: B値] [4バイト: A値]
  または
  [4バイト: R] [4バイト: G] [4バイト: B] [4バイト: A]
  ```
- **例**:
  ```
  0x0520: 04 00 08 00 0a 00 00 00 00 00 80 3f 00 00 00 3f
  → RGBA(0.0, 0.0, 1.0, 0.5) = RGB(0, 0, 255, 127)
  ```

**注意**: 最初の8バイト（`04 00 08 00 0a 00 00 00`）の解釈は不明確。
- 可能性1: R=0.0, G=0.0としてのfloat値（偶然0になっている）
- 可能性2: FlatBuffersのVTableオフセットやメタデータ

---

## 🔬 検証されたパターン

### パターン1: 同じサイズ、異なる色

**Fontstyle_01 vs Fontstyle_02（両方732バイト）**:
- 差分: **たった1バイト**（0x0216）
- RGB bytes形式の色データの1バイトのみが異なる

### パターン2: 同じ色、異なるサイズ

**Fontstyle_01 (732バイト) vs Fontstyle_11 (916バイト)**:
- 両方とも **同じRGB塗り色**: R=0 G=253 B=113 A=113
- サイズ差: **184バイト** = ストロークデータ1つ分

### パターン3: 同じストローク設定

**Fontstyle_11-15（全て916バイト）**:
- すべて**同じストローク幅**: 16.0 pt
- すべて**同じストローク色**: RGB(0, 0, 255, 127)

---

## 📐 ストロークデータ構造（推定）

### 基本構造（184バイト）

```
オフセット    サイズ    内容
------------------------------------------
+0x0000      ?       VTable/メタデータ
+0x0028      4       不透明度 (float, 100.0)
+0x002c      4       ストローク幅 (float, 16.0 pt)
+0x0064      16      ストローク色1 RGBA float
+0x0094      16      ストローク色2 RGBA float
...          ...     その他のパラメータ
```

**注意**: 正確なオフセットはFlatBuffersの可変長レイアウトにより変動する

---

## 🎨 グラデーションストロークの推定

### 2色グラデーション

Fontstyle_11で検出された2箇所の同じ青色：
- 位置1 (0x01bc): RGB(0, 0, 255, 127)
- 位置2 (0x01ec): RGB(0, 0, 255, 127)

**推測**: グラデーションのstart colorとend colorが同じ
→ 単色ストロークだがグラデーション構造を使用している可能性

### 複数色グラデーション

Fontstyle_90で検出された異なる色：
- 黒 (0x051c, 0x0644): RGB(0, 0, 0, 255)
- 青 (0x0520, 0x0648): RGB(0, 0, 255, 127)

**推測**:
- 黒→青のグラデーションストローク
- または複数のストロークレイヤー（黒レイヤー + 青レイヤー）

---

## 🔍 まだ解明されていないパラメータ

### ストローク関連
- ✅ ストローク幅: 解明済み（0x0184付近、float）
- ✅ ストローク色: 部分的に解明（RGBA float形式）
- ❓ ストローク位置: 未解明（内側/外側/中央）
- ❓ ストロークのぼかし: 未解明
- ❓ グラデーションストップ位置: 未解明

### シャドウ関連
- ❓ シャドウの有無: 未確認
- ❓ シャドウの色: 未解明
- ❓ シャドウのオフセット（X, Y）: 未解明
- ❓ シャドウのぼかし: 未解明
- ❓ シャドウの不透明度: 未解明

---

## 💡 実装への示唆

### フォーズ1: 基本的なストローク対応

以下のパラメータが判明しているため、基本的なストローク付きスタイルの生成は可能：

1. **ストローク幅**: 固定位置（0x0184付近）に書き込み
2. **ストローク色**: RGBA float形式で2箇所に書き込み（グラデーション用）
3. **不透明度**: 100.0を固定位置（0x0180付近）に書き込み

### 実装方法

**テンプレートベース**:
```python
# 916バイトのストローク付きテンプレートを使用
template = load_template("stroke_template_916.prtextstyle")

# ストローク幅を変更
template[0x184:0x188] = struct.pack("<f", stroke_width)

# ストローク色を変更（RGBA float）
r, g, b, a = stroke_color_rgba_normalized  # 0.0-1.0
template[0x1bc+8:0x1bc+16] = struct.pack("<ff", b, a)
template[0x1ec+8:0x1ec+16] = struct.pack("<ff", b, a)
```

**注意**:
- 正確なオフセットはFlatBuffersレイアウトにより変動する可能性あり
- パターンマッチングで動的に位置を検出する方が安全

---

## 📈 次のステップ

### 優先度 HIGH

1. **ストローク位置パラメータの特定**
   - 内側/外側/中央の違いを持つスタイルを比較
   - バイナリ差分からパラメータ位置を特定

2. **シャドウパラメータの完全解明**
   - シャドウあり/なしのスタイルを比較
   - オフセット（X, Y）、ぼかし、色、不透明度の位置を特定

3. **グラデーションストップの詳細**
   - ストップ位置（0.0-1.0）の格納位置
   - 中間点パラメータの解明

### 優先度 MEDIUM

4. **より多くのスタイルサンプルの解析**
   - 200 New FontStyles_01.prtextstyleの詳細解析
   - 異なるストローク設定を持つスタイルの比較

5. **FlatBuffers VTableの完全理解**
   - オフセット計算ロジックの解明
   - 動的なパラメータ位置検出アルゴリズムの実装

---

## 📚 関連ファイル

### 解析ツール
- `analyze_184byte_difference.py` - 184バイト差分の詳細解析
- `analyze_100_200_styles.py` - 300スタイルの統計解析
- `compare_style_patterns.py` - スタイルパターン比較

### ドキュメント
- `MULTI_STYLE_ANALYSIS.md` - 300スタイルの解析結果
- `FINAL_BINARY_FORMAT_FINDINGS.md` - 単一スタイルのバイナリ解析

---

**結論**: **ストローク幅と色データの位置を特定できた**。基本的なストローク付きスタイルの生成は実装可能なレベルに到達。次は、シャドウパラメータとグラデーション詳細の解明が必要。
